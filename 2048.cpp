//preprocessor directives
#include<iostream>
#include<ctime>
#include<algorithm>
#include<stdlib.h>
#include<fstream>
#include<iomanip>
#include "2048.h"

/**
 *This gives a seed for the random generator.
 */
void initializeRandomGenerator(unsigned int seed = time(NULL));
void initializeRandomGenerator(unsigned int seed) {
  std::srand(seed);
}

/**
 *This function randomly adds a tile of value 2 or 4 to the board after each valid turn.
 *The random value generated by rand() determines which tile will have a value added and whether that value is 2 or 4.
 */
void G2048::addTile(){
	bool add = false;
	for(int x = 0; x<4 ; x++){
		for(int y = 0; y<4 ; y++){
			if (board[x][y] == 0){
				int z = rand()%16;
				if ((z % 4) == 0){
					if (z == 0)
						board[x][y] = 4;
					else
						board[x][y] = 2;
					add = true;
				}
			}
			if (add)
				break;
		}
		if (add)
			break;
	}
}

/**
 *This function prompts for an input character from the player, then returns the value.
 *If the player inputs a series of characters, it will only take the first one.
 */
char G2048::getInput(){
	char move;
	std::cin>>move;
	std::cin.ignore(100,'\n'); // ignore up to 100 characters or until next line
	return move;
}

/**
 *This function moves the tiles in the specified direction using nested loops.
 *If two same tiles are the same are moved next to each other, they are combined into one and the new value is added to the score.
 *But like in the game, the tiles are only added if they have not yet been combined for this move. (ex. Tiles are moved to the right = [2][2][2][2] -> [ ][ ][4][4]).
 *It returns true if the state of the board has changed (move is valid).
 *If the player inputs a character not in the choices, the program will return false.
 */
bool G2048::move(char direction){
	int ctr, temp = 0, next;
	bool move = false;
	if (direction == 'W' || direction == 'w'){
		for (int y=0; y<4;y++){
			ctr = 0;
			for (int x=0; x<4; x++){
				if (board[x][y] != 0){
					next = board[x][y];
					board[x][y] = 0;
					if (temp == next && ctr != 0){
						board[ctr-1][y] = temp + next;
						temp = 0; // temp is returned to zero to check if there is a next pair of same numbers
						score += board[ctr-1][y];
					}
					else{
						board[ctr][y] = next;
						temp = next;
						ctr++;
					}
					move = true;
				}
			}
		}		
	}	
	else if (direction == 'S' || direction == 's'){
		for (int y=0; y<4;y++){
			ctr = 3;
			for (int x=3; x>=0; x--){
				if (board[x][y] != 0){
					next = board[x][y];
					board[x][y] = 0;
					if (temp == next && ctr != 3){
						board[ctr+1][y] = temp + next;
						temp = 0;
						score += board[ctr+1][y];
					}
					else{
						board[ctr][y] = next;
						temp = next;
						ctr--;
					}
					move = true;
				}
			}
		}
	}
	else if (direction == 'A' || direction == 'a'){
		for (int x=0; x<4;x++){
			ctr = 0;
			for (int y=0; y<4; y++){
				if (board[x][y] != 0){
					next = board[x][y];
					board[x][y] = 0;
					if (temp == next && ctr != 0){
						board[x][ctr-1] = temp + next;
						temp = 0;
						score += board[x][ctr-1];
					}
					else{
						board[x][ctr] = next;
						temp = next;
						ctr++;
					}
					move = true;
				}
			}
		}
	}
	else if (direction == 'D' || direction == 'd'){
		for (int x=0; x<4;x++){
			ctr = 3;
			for (int y=3; y>=0; y--){
				if (board[x][y] != 0){
					next = board[x][y];
					board[x][y] = 0;
					if (temp == next && ctr != 3){
						board[x][ctr+1] = temp + next;
						temp = 0;
						score += board[x][ctr+1];
					}
					else{
						board[x][ctr] = next;
						temp = next;
						ctr--;
					}
					move = true;
				}
			}
		}
	}
	return move;
}

/**
 *This function clears the terminal and prints the current score, state of the board and the directional keys.
 *The functions used for clearing the screen has only been tested on a Windows machine .
 *This function will also notify the player if they have reached 2048.
 */
void G2048::drawBoard(){
	if(system("cls"))
		system("clear");
	std::cout<<"Score: "<<score<<std::endl<<std::endl;
	if (hasReached2048())
		std::cout<<"You've Reached 2048!"<<std::endl;
	else
		std::cout<<std::endl;
	for(int x = 0; x<4; x++){
		std::cout<<"[-----+-----+-----+-----]"<<std::endl;
		for(int y = 0; y<4; y++){
			if (board[x][y] == 0)
				std::cout<<'|'<<std::setw(5)<<" ";
			else
				std::cout<<'|'<<std::setw(5)<<board[x][y];
		}
		std::cout<<"|"<<std::endl;
	}
	std::cout<<"[-----+-----+-----+-----]"<<std::endl<<std::endl;
	std::cout<<"(W)Up (S)Down (A)Left (D)Right (Q)Quit"<<std::endl;
}	

/**
 *This function checks if the game is already won.
 *Tiles are checked for 2048 using nested loops.
 */
bool G2048::hasReached2048(){
	bool has2048 = false;
	for(int x = 0; x<4; x++){
		for(int y = 0; y<4; y++){
			if(board[x][y] == 2048)
				has2048 = true;
		}
	}	
	return has2048;
}

/**
 *This function uses nested loops to checks if there is still a possible move.
 *There is a move left if at least one tile is blank (board[x][y] == 0) or if there are still tiles of the same value next to each other.
 */
bool G2048::hasMove(){
	bool move = false;
	for(int x = 0; x<4; x++){
		for(int y = 0; y<4; y++){
			if(board[x][y] == 0){
				move = true;
				break;
			}
		}
		if (move)
			break;
	}
	for(int x = 0; x<4; x++){
		for(int y = 0; y<4; y++){
			if(x<3)
				if(board[x][y] == board[x+1][y]){
					move = true;
					break;
				}
			if(y<3)
				if(board[x][y] == board[x][y+1]){
					move = true;
					break;
				}
		}
		if (move)
			break;
	}
	if (move == false)
		std::cout<<"No more moves left!"<<std::endl;
	return move;
}

/**
 *This function tries to load a 2048 game from the specified file.
 *If it fails to open the file, it loads a fresh board.
 *Failure to open a file can be because the file extension used was wrong.
 *The program is also not able to check if a file is a valid file for the game.
 */
void G2048::loadGame(){
	std::ifstream input;
	input.open(filename);//check if file exist/not empty
	if (input.fail()){
		score = 0;
		for(int x = 0; x<4; x++)
			for(int y = 0; y<4; y++){
				board[x][y] = 0;
		}
		addTile();
	}
	else{
		input>>score;
		for(int x = 0; x<4; x++){
			for(int y = 0; y<4; y++){
				input>>board[x][y];
			}		
		}
	}
	input.close();
}

/**
 *This function asks the player if the want to save the game or not.
 *If yes, it saves the instance of this class to the specified file.
 *Note: If the argument does not have a filename, the program saves it without adding a filename.
 *If the argument is NULL, the player is prompted for a filename.
 */
void G2048::saveGame(){
	char save;
	std::cout<<"Save game? (Y)Yes (N)No: ";
	std::cin>>save;
	if(save == 'Y' || save == 'y'){
		std::string file;
		if (filename == NULL){
			std::cout<<"Enter filename: ";
			std::cin>>file;
			file = file + ".txt";
			filename = &file[0];
		}
		std::ofstream output;
		output.open(filename);
		output<<score<<'\n';
		int x, y;
		for(x = 0; x<4; x++){
			for(y = 0; y<3; y++){
				output<<board[x][y]<<' ';
			}
			output<<board[x][y]<<'\n';
		}		
		output.close();
		std::cout<<"Your game was saved!. Thanks for playing!"<<std::endl;
	}
	else if(save == 'N' || save == 'n'){
		std::cout<<"Your game was not saved. Thanks for playing!"<<std::endl;
	}
	else
		saveGame();
}

/**
 *This initializes a game of 2048 - the board, score, and filename.            
 *If there is no filename given, a fresh board is given, else, the function loadGame() is called.
 */
G2048::G2048(char* file){
	filename = file;
	if (filename == NULL){
		score = 0;
		for(int x = 0; x<4; x++)
			for(int y = 0; y<4; y++)
				board[x][y] = 0;
		addTile();
	}
	else
		loadGame();
}

/**  
 *This function starts/resumes a game of 2048.
 *For as long there are valid moves, the games continues until the player decides to quit or there are no moves left.
 *Every loop the program asks for an input. If the player gives a valid move, addTile() is called.
 *When the loop is broken, saveGame() is called and the program ends.
 */
void G2048::startGame(){
	initializeRandomGenerator();
	char dir;
	bool quit = false;
	while(hasMove()){
		drawBoard();
		dir = getInput();
		if (dir == 'Q' || dir == 'q'){
			quit = true;
			break;
		}
		if (quit)
			break;
		if(move(dir))
			addTile();
	}
	saveGame();
}